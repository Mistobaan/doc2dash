from __future__ import absolute_import, division, print_function

import errno
import logging
import os
import sys

from collections import defaultdict

import click
import six

from bs4 import BeautifulSoup
from characteristic import attributes


log = logging.getLogger(__name__)


@attributes(["name", "type", "anchor"])
class TOCEntry(object):
    """
    A symbol entry generated by the parser and to be added to the TOC.
    """


@attributes(["name", "type", "path"])
class ParserEntry(object):
    """
    A symbol as found by the parser that get yield for further processing.
    """
    def as_tuple(self):
        """
        Return a tuple of the data for SQL generation.
        """
        return self.name, self.type, self.path


if sys.version_info.major > 2:  # pragma: nocover
    def coroutine(func):
        def start(*args, **kwargs):
            g = func(*args, **kwargs)
            g.__next__()
            return g
        return start
else:
    def coroutine(func):
        def start(*args, **kwargs):
            g = func(*args, **kwargs)
            g.next()
            return g
        return start


APPLE_REF_TEMPLATE = '//apple_ref/cpp/{}/{}'


class _BaseParser(object):
    """
    Abstract parser base class.
    """
    APPLE_REF = APPLE_REF_TEMPLATE
    """
    Backward compatibility only, don't use in new code.
    """

    def __init__(self, docpath):
        self.docpath = docpath

    @classmethod
    def detect(cl, path):
        """
        Detect whether *path* is documentation of the type of the class
        that sub-classes _BaseParser.  This is ugly and should be replaced by
        composition eventually.

        Until then, sub-classes need to set class-attributes DETECT_FILE with
        a file name to check and DETECT_PATTERN that has to be contained within
        that file.
        """
        try:
            with open(os.path.join(path, cl.DETECT_FILE), "rb") as f:
                return cl.DETECT_PATTERN in f.read()
        except IOError as e:
            if e.errno == errno.ENOENT:
                return False
            else:
                raise

    @coroutine
    def add_toc(self, show_progressbar):
        """
        Consume tuples as returned by parse(), then patch docs for TOCs.
        """
        files = defaultdict(list)
        try:
            while True:
                pentry = (yield)
                try:
                    fname, anchor = pentry.path.split('#')
                    files[fname].append(
                        TOCEntry(name=pentry.name,
                                 type=pentry.type,
                                 anchor=anchor)
                    )
                except ValueError:
                    # pydoctor has no anchors for e.g. classes
                    pass
        except GeneratorExit:
            pass

        def patch_files(files):
            for fname, entries in files:
                full_path = os.path.join(self.docpath, fname)
                with open(full_path) as fp:
                    soup = BeautifulSoup(fp, 'lxml')
                    for entry in entries:
                        if not self.find_and_patch_entry(soup, entry):
                            log.debug("Can't find anchor {} in {}."
                                      .format(entry.anchor,
                                              click.format_filename(fname)))
                with open(full_path, 'w') as fp:
                    fp.write(str(soup))

        if show_progressbar is True:
            with click.progressbar(
                    six.iteritems(files), width=0, length=len(files),
                    label='Adding table of contents meta data...') as pbar:
                patch_files(pbar)
        else:
            patch_files(six.iteritems(files))
